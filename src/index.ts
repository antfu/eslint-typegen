import { existsSync } from 'node:fs'
import fs from 'node:fs/promises'
import type { Linter } from 'eslint'
import { hash as makeHash } from 'ohash'
import { version } from '../package.json'
import type { FlatConfigsToPluginsOptions } from './core'
import { flatConfigsToPlugins, pluginsToRulesDTS } from './core'

export interface TypeGenOptions extends FlatConfigsToPluginsOptions {
  /**
   * Include core rules in the generated types.
   *
   * @default true
   */
  includeCoreRules?: boolean

  /**
   * Path to the generated types file.
   */
  dtsPath?: string
}

/**
 * Wrap with resolved flat configs to generates types for rules.
 */
export default async function typegen(
  configs: Promise<Linter.FlatConfig[]> | Linter.FlatConfig[],
  options: TypeGenOptions = {},
): Promise<Linter.FlatConfig[]> {
  const {
    includeCoreRules = true,
    dtsPath = 'eslint-typegen.d.ts',
  } = options

  const resolved = await configs
  let configsInput = resolved

  if (includeCoreRules) {
    const { builtinRules } = await import('eslint/use-at-your-own-risk')
    configsInput = [
      {
        plugins: {
          '': { rules: Object.fromEntries(builtinRules.entries()) },
        },
      },
      ...configsInput,
    ]
  }

  const plugins = await flatConfigsToPlugins(configsInput, options)
  const hashSource = Object.entries(plugins)
    .map(([n, p]) => [p.meta?.name, p.meta?.version].filter(Boolean).join('@') || p.name || n)
    .sort()
  const hash = makeHash(`${hashSource} ${version}`)

  const previousHash = existsSync(dtsPath)
    ? (await fs.readFile(dtsPath, 'utf-8')).match(/\/\* eslint-typegen-hash: ([^\s]*)? \*\//)?.[1]?.trim()
    : undefined

  if (previousHash !== hash) {
    const dts = [
      '/* This file is generated by eslint-typegen, for augmenting rules types in ESLint */',
      '/* You might want to include this file in tsconfig.json but excluded from git */',
      `/* eslint-typegen-hash: ${hash} */`,
      '',
      await pluginsToRulesDTS(plugins),
    ].join('\n')

    fs.writeFile(dtsPath, dts, 'utf-8')
  }

  return resolved
}
